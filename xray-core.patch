diff -Naur a/core/domain2ip.go b/core/domain2ip.go
--- a/core/domain2ip.go	1970-01-01 00:00:00.000000000 +0000
+++ b/core/domain2ip.go	2025-11-12 16:24:48.678480697 +0000
@@ -0,0 +1,40 @@
+package core
+
+import (
+	"sync"
+)
+
+// DomainToIPs is a map of domain names to IP addresses
+// Note: there may be multiple IP addresses for a given domain
+var DomainToIPs = map[string][]string{}
+var domainMutex sync.RWMutex
+
+// GetDomainIPs returns IP addresses for a given domain
+func GetDomainIPs(domain string) ([]string, bool) {
+	domainMutex.RLock()
+	defer domainMutex.RUnlock()
+	ips, ok := DomainToIPs[domain]
+	return ips, ok
+}
+
+// SetDomainIPs sets IP addresses for a given domain
+func SetDomainIPs(domain string, ips []string) {
+	domainMutex.Lock()
+	defer domainMutex.Unlock()
+	DomainToIPs[domain] = ips
+}
+
+// DropDomainIPs drops specific IP address for a given domain from the cache
+func DropDomainIPs(domain string, ip string) {
+	domainMutex.Lock()
+	defer domainMutex.Unlock()
+	for i, existingIP := range DomainToIPs[domain] {
+		if existingIP == ip {
+			DomainToIPs[domain] = append(DomainToIPs[domain][:i], DomainToIPs[domain][i+1:]...)
+			if len(DomainToIPs[domain]) == 0 {
+				delete(DomainToIPs, domain)
+			}
+			break
+		}
+	}
+}
diff -Naur a/envoy/xray.go b/envoy/xray.go
--- a/envoy/xray.go	1970-01-01 00:00:00.000000000 +0000
+++ b/envoy/xray.go	2025-11-12 17:06:40.552434036 +0000
@@ -0,0 +1,189 @@
+package xray
+
+// copied and modified from main/commands/run.go
+
+// feeding core.LoadConfig with a string reader containing the config
+// JSON seems the simplest way to run xray as a library
+//
+// Golang's JSON support seems a little cumbersome for a couple
+// string substitutions in a complex JSON snippet, so we just
+// use fmt.Sprintf to assemble the config
+//
+// The JSON file we build should look similar to the client example config
+// (that will be) documented here:
+// https://gitlab.com/stevenmcdonald/envoy-proxy-examples/v2ray/
+
+// We provide functions for starting and stopping several client services
+// independently. Unfortunately you can't start them all and tell xray to
+// use the one that works... but that's what Envoy is good at.
+
+import (
+	"fmt"
+	"os"
+	"os/signal"
+	"strings"
+	"syscall"
+
+	core "github.com/xtls/xray-core/core"
+	_ "github.com/xtls/xray-core/main/distro/all"
+)
+
+const jsonV5 = "json"
+
+var osXrxhSignals = make(chan os.Signal, 1)
+
+// getInbound
+//
+// @param port - port to listen for SOCKS5 connections
+func getInbound(clientPort int) string {
+	return fmt.Sprintf(`
+      {
+        "port": %d,
+        "protocol": "socks",
+        "sniffing": {
+          "enabled": true,
+          "destOverride": ["http", "tls"]
+        },
+        "settings": {}
+      }`, clientPort)
+}
+
+func getXrxhConfig(clientPort int, serverAddress, serverPort, xhttpPath, id string, allowInsecure bool, serverName string, hostName string, xhttpMode string) string {
+	return fmt.Sprintf(`
+  {
+    "log": {
+      "loglevel": "warning"
+    },
+    "inbounds": [%s
+    ],
+    "outbounds": [
+      {
+        "protocol": "vless",
+        "settings": {
+          "vnext": [
+            {
+              "address": "%s",
+              "port": %s,
+              "users": [
+                {
+                  "id": "%s",
+                  "encryption": "none"
+                }
+              ]
+            }
+          ]
+        },
+        "streamSettings": {
+          "network": "xhttp",
+          "xhttpSettings": {
+            "host": "%s",
+            "path": "%s",
+            "mode": "%s"
+          },
+          "security": "tls",
+          "tlsSettings": {
+            "serverName": "%s",
+            "allowInsecure": %t,
+            "alpn": ["h2", "http/1.1"]
+          }
+        }
+      }
+    ]
+  }`, getInbound(clientPort), serverAddress, serverPort, id, hostName, xhttpPath, xhttpMode, serverName, allowInsecure)
+}
+
+func startServer(jsonConfig string) (*core.Instance, error) {
+	// fmt.Printf("DEBUG: Xray JSON config:\n%s\n", jsonConfig)
+	reader := strings.NewReader(jsonConfig)
+
+	config, err := core.LoadConfig(jsonV5, reader)
+	if err != nil {
+		fmt.Printf("error reading config: %s\n", err)
+		return nil, err
+	}
+
+	server, err := core.New(config)
+	if err != nil {
+		fmt.Printf("error creating server: %s\n", err)
+		return nil, err
+	}
+
+	if err := server.Start(); err != nil {
+		fmt.Printf("failed to start %s\n", err)
+
+		_ = server.Close()
+
+		return nil, err
+	}
+
+	return server, nil
+}
+
+// XrxhConfigOptional holds optional configuration for Xrxh connections
+type XrxhConfigOptional struct {
+	AllowInsecure bool
+	ServerName    string
+	Hostname      string
+	XhttpMode     string
+}
+
+// StartXrxh - start Xray with XHTTP transport
+//
+// @param clientPort - client SOCKS port routed to the XHTTP server
+//
+// @param serverAddress - IP or hostname of the server
+//
+// @param serverPort - port of the XHTTP server (probably 443)
+//
+// @param xhttpPath - path to the XHTTP endpoint on the server
+//
+// @param id - UUID used to authenticate with the server
+//
+// @param config - optional configuration (allowInsecure defaults to false,
+// serverName defaults to serverAddress, xhttpMode defaults to stream-one)
+//
+// @returns error, if transport could not be started, or `nil` on success.
+func StartXrxh(clientPort int, serverAddress, serverPort, xhttpPath, id string, config ...XrxhConfigOptional) error {
+	// Set defaults for optional config
+	allowInsecure := false
+	serverName := serverAddress
+	hostName := serverAddress
+	xhttpMode := "stream-one"
+
+	// Override with provided config if any
+	if len(config) > 0 {
+		cfg := config[0]
+		allowInsecure = cfg.AllowInsecure
+		if cfg.ServerName != "" {
+			serverName = cfg.ServerName
+		}
+		if cfg.Hostname != "" {
+			hostName = cfg.Hostname
+		}
+		if cfg.XhttpMode != "" {
+			xhttpMode = cfg.XhttpMode
+		}
+	}
+
+	server, err := startServer(getXrxhConfig(clientPort, serverAddress, serverPort, xhttpPath, id, allowInsecure, serverName, hostName, xhttpMode))
+	if err != nil {
+		return err
+	}
+
+	go func(server *core.Instance) {
+		defer func(server *core.Instance) {
+			_ = server.Close()
+		}(server)
+
+		{
+			signal.Notify(osXrxhSignals, syscall.SIGTERM)
+			<-osXrxhSignals
+		}
+	}(server)
+
+	return nil
+}
+
+func StopXrxh() {
+	osXrxhSignals <- syscall.SIGTERM
+}
diff -Naur a/proxy/wireguard/tun.go b/proxy/wireguard/tun.go
--- a/proxy/wireguard/tun.go	2025-10-14 20:23:35.482996098 +0000
+++ b/proxy/wireguard/tun.go	2025-11-06 13:06:30.235470037 +0000
@@ -194,7 +194,7 @@
 					Timeout: 15 * time.Second,
 				})
 
-				handler(xnet.UDPDestination(xnet.IPAddress(id.LocalAddress.AsSlice()), xnet.Port(id.LocalPort)), gonet.NewUDPConn(&wq, ep))
+				handler(xnet.UDPDestination(xnet.IPAddress(id.LocalAddress.AsSlice()), xnet.Port(id.LocalPort)), gonet.NewUDPConn(stack, &wq, ep))
 			}(r)
 		})
 		stack.SetTransportProtocolHandler(udp.ProtocolNumber, udpForwarder.HandlePacket)
diff -Naur a/transport/internet/splithttp/dialer.go b/transport/internet/splithttp/dialer.go
--- a/transport/internet/splithttp/dialer.go	2025-10-14 20:23:35.490996211 +0000
+++ b/transport/internet/splithttp/dialer.go	2025-11-12 16:41:49.620411943 +0000
@@ -21,6 +21,7 @@
 	"github.com/xtls/xray-core/common/net"
 	"github.com/xtls/xray-core/common/signal/done"
 	"github.com/xtls/xray-core/common/uuid"
+	core "github.com/xtls/xray-core/core"
 	"github.com/xtls/xray-core/transport/internet"
 	"github.com/xtls/xray-core/transport/internet/browser_dialer"
 	"github.com/xtls/xray-core/transport/internet/reality"
@@ -253,6 +254,17 @@
 		dest.Network = net.Network_UDP
 	}
 
+	// Only try to resolve using GetDomainIPs if the address is a domain, not an IP
+	var originalDomain string
+	if dest.Address.Family().IsDomain() {
+		originalDomain = dest.Address.Domain()
+		if ips, ok := core.GetDomainIPs(originalDomain); ok {
+			dest.Address = net.ParseAddress(ips[0])
+		}
+	} else {
+		originalDomain = dest.Address.String()
+	}
+
 	transportConfiguration := streamSettings.ProtocolSettings.(*Config)
 	var requestURL url.URL
 
@@ -269,7 +281,7 @@
 		requestURL.Host = realityConfig.ServerName
 	}
 	if requestURL.Host == "" {
-		requestURL.Host = dest.Address.String()
+		requestURL.Host = originalDomain
 	}
 
 	sessionIdUuid := uuid.New()
@@ -311,6 +323,18 @@
 		if httpVersion2 == "3" {
 			dest2.Network = net.Network_UDP
 		}
+
+		// Only try to resolve using GetDomainIPs if the address is a domain, not an IP
+		var originalDomain string
+		if dest2.Address.Family().IsDomain() {
+			originalDomain = dest2.Address.Domain()
+			if ips, ok := core.GetDomainIPs(originalDomain); ok {
+				dest2.Address = net.ParseAddress(ips[0])
+			}
+		} else {
+			originalDomain = dest2.Address.String()
+		}
+
 		if tlsConfig2 != nil || realityConfig2 != nil {
 			requestURL2.Scheme = "https"
 		} else {
@@ -325,7 +349,7 @@
 			requestURL2.Host = realityConfig2.ServerName
 		}
 		if requestURL2.Host == "" {
-			requestURL2.Host = dest2.Address.String()
+			requestURL2.Host = originalDomain
 		}
 		requestURL2.Path = config2.GetNormalizedPath() + sessionIdUuid.String()
 		requestURL2.RawQuery = config2.GetNormalizedQuery()
